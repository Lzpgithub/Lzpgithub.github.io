---
layout: post
title: C/C++程序中的内存分配问题
categories: C和C++基础
description: C/C++程序中的内存分配问题
keywords: 内存分配问题
---

#### 程序的内存分配

一个由C/C++编译的程序占用的内存分为以下几个部分：

**1、栈区（stack）**——由编译器自动分配和释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

**2、堆区（heap）**——一般由程序员分配和释放，若程序员不释放，则程序结束时可能由操作系统回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。

**3、全局区（静态区）（static）**——全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域（数据段），未初始化的全局变量和未初始化的静态变量在相邻的另一块区域（BSS段）。程序结束后由系统释放。

**4、文字常量区**——（属于代码段）常量字符串就是放在这里的。程序结束后由系统释放。

**5、程序代码区**——存放函数体的二进制代码（代码段）。

#### 举例说明

```cpp
#include <malloc.h>
#include <string.h>

int a = 0;                       //全局初始化区
char* p1;                        //全局未初始化区

void main(){
	int b;                       //栈
	char s[] = "abc";            //栈
	char* p2;                    //栈
	char* p3 = "123456";         //123456\0 在常量区  p3在栈上
	static int c = 0;            //全局（静态）初始化区
	p1 = (char*) malloc(10);
	p2 = (char*) malloc(20);     //分配得来得10和20字节的区域就在堆区。
	strcpy(p1, "123456");        //123456\0放在常量区  编译器可能会将它与p3所指向的"123456"优化成一个地方。
	free(p1);
	free(p2);
}
```

#### 堆和栈的理论知识

##### 1.申请方式

栈：由系统自动分配。例如，声明在函数中的一个局部变量int b; 系统自动在栈中为b开辟空间。

堆：需要程序员自己申请，并指明大小，在c 中使用malloc 函数，在C++中使用new运算符。例如：

```cpp
char *p1,*p2;
p1 = (char*)malloc(10);  // C（当然也可以在C++中）
p2 = new char[10];       //C++
```

但是注意 p1、p2 本身是在栈中的。

##### 2.申请后系统的响应

栈：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。

堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete 语句才能正确地释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

#### 3.申请大小的限制

栈：在Windows 下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的。在Windows 下，栈的大小是1M（也有说是2M 的），如果申请的空间超过栈的剩余空间时，将提示Overflow。因此，能从栈获得的空间较小。

堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

#### 4.申请效率的比较

栈由系统自动分配，速度较快，但程序员是无法控制的。

堆是由malloc或new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来很方便。

另外，在Windows下，最好的方式是用VirtualAlloc分配内存，它不是在堆，也不是在栈，而是直接在进程的地址空间中保留一快内存。虽然用起来很不方便，但是速度快，也最灵活。

#### 5.堆和栈中的存储内容


栈：在函数调用时，第一个进栈的是主函数中的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。

当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。

#### 6.存取效率的比较

```cpp
char s1[] = "aaaaaaaaaaaaaaa";
char* s2 = "bbbbbbbbbbbbbbbbb";
```

"aaaaaaaaaaa"是在运行时刻赋值的；而"bbbbbbbbbbb"是在编译时就确定的。但是，在以后的存取中，在栈上的数组比指针所指向的字符串（例如堆）快。比如：

```cpp
void main(){
	char a = 1;
	char c[] = "1234567890";
	char* p = "1234567890";
	a = c[1];
	a = p[1];
	return;
}
```

对应的汇编代码：

![](/images/posts/C++/154.png)

第一种在读取时直接就把字符串中的元素读到寄存器cl 中，而第二种则要先把指针值读到edx 中，再根据edx 读取字符，显然慢了。

#### 总结

其实堆和栈的区别可以用下面形象的比喻来描述：使用栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度较小。而使用堆就像是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度较大。

#### C语言中内存分布及程序运行中(BSS段、数据段、代码段、堆栈）

**BSS段:（bss segment）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域**。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。

**数据段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量和静态变量的一块内存区域。**数据段属于静态内存分配。 

**代码段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。**这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读，某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些 只读的常数变量，例如字符串常量等。程序段为程序代码在内存中的映射。一个程序可以在内存中多有个副本。

**堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。**当进程调用malloc/free等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）/释放的内存从堆中被剔除（堆被缩减）。

**栈(stack)：栈又称堆栈，存放程序的 局部变量（但不包括static声明的变量，static意味着在数据段中存放变量）**。除此以外，在函数被调用时，栈用来传递参数和返回值。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。储动态内存分配,需要程序员手工分配,手工释放。

![](/images/posts/C++/287.png)

一个典型C内存空间分布图：

![](/images/posts/C++/284.png)

```cpp
#include <stdio.h>
#include <stdlib.h>
int g1=0, g2=0, g3=0;
int max(int i)
{
    int m1=0,m2,m3=0,*p_max;
    static int n1_max=0,n2_max,n3_max=0;
     p_max = (int*)malloc(10);
    printf("打印max程序地址\n");
    printf("in max: 0x%08x\n\n",max);
    printf("打印max传入参数地址\n");
    printf("in max: 0x%08x\n\n",&i);
    printf("打印max函数中静态变量地址\n");
    printf("0x%08x\n",&n1_max); //打印各本地变量的内存地址
    printf("0x%08x\n",&n2_max);
    printf("0x%08x\n\n",&n3_max);
    printf("打印max函数中局部变量地址\n");
    printf("0x%08x\n",&m1); //打印各本地变量的内存地址
    printf("0x%08x\n",&m2);
    printf("0x%08x\n\n",&m3);
    printf("打印max函数中malloc分配地址\n");
    printf("0x%08x\n\n",p_max); //打印各本地变量的内存地址

    if(i) return 1;
    else return 0;
}

int main(int argc, char **argv)
{
    static int s1=0, s2, s3=0;
    int v1=0, v2, v3=0;
    int *p;    
    p = (int*)malloc(10);

    printf("打印各全局变量(已初始化)的内存地址\n");
    printf("0x%08x\n",&g1); //打印各全局变量的内存地址
    printf("0x%08x\n",&g2);
    printf("0x%08x\n\n",&g3);
    printf("======================\n");
    printf("打印程序初始程序main地址\n");
    printf("main: 0x%08x\n\n", main);
    printf("打印主参地址\n");
    printf("argv: 0x%08x\n\n",argv);
    printf("打印各静态变量的内存地址\n");
    printf("0x%08x\n",&s1); //打印各静态变量的内存地址
    printf("0x%08x\n",&s2);
    printf("0x%08x\n\n",&s3);
    printf("打印各局部变量的内存地址\n");
    printf("0x%08x\n",&v1); //打印各本地变量的内存地址
    printf("0x%08x\n",&v2);
    printf("0x%08x\n\n",&v3);
    printf("打印malloc分配的堆地址\n");
    printf("malloc: 0x%08x\n\n",p);
    printf("======================\n");
    max(v1);
    printf("======================\n");
    printf("打印子函数起始地址\n");
    printf("max: 0x%08x\n\n",max);
    system("pause");
}
```

![](/images/posts/C++/285.png)

可以大致查看整个程序在内存中的分配情况：

可以看出，传入的参数，局部变量，都是在栈顶分布，随着子函数的增多而向下增长。
函数的调用地址(函数运行代码)，全局变量，静态变量都是在分配内存的低部存在，而malloc分配的堆则存在于这些内存之上，并向上生长。

在操作系统中，一个进程就是处于执行期的程序（当然包括系统资源），实际上正在执行的程序代码的活标本。那么进程的逻辑地址空间是如何划分的呢？

![](/images/posts/C++/286.png)

左边的是UNIX/LINUX系统的执行文件，右边是对应进程逻辑地址空间的划分情况。

首先是堆栈区(stack)，堆栈是由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。栈的申请是由系统自动分配，如在函数内部申请一个局部变量 int h，同时判别所申请空间是否小于栈的剩余空间，如若小于的话，在堆栈中为其开辟空间，为程序提供内存，否则将报异常提示栈溢出。    

其次是堆(heap)，堆一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。堆的申请是由程序员自己来操作的，在C中使用malloc函数，而C++中使用new运算符，但是堆的申请过程比较复杂：当系统收到程序的申请时，会遍历记录空闲内存地址的链表，以求寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，此处应该注意的是有些情况下，新申请的内存块的首地址记录本次分配的内存块大小，这样在delete尤其是delete[]时就能正确的释放内存空间。

接着是全局数据区(静态区) (static)，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 另外文字常量区，常量字符串就是放在这里，程序结束后有系统释放。

最后是程序代码区，放着函数体的二进制代码。
