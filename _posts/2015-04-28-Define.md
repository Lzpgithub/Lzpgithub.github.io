---
layout: post
title: C/C++之define用法小结
categories: C和C++基础
description: define的用法。
keywords: define
---

##### 1、define--（无参数宏定义）用法

一般形式为：

**#define 标识符 字符串**

（1）"#"表示其为预处理命令，凡是以"#"开头的都是预处理命令；"define"为宏定义命令；"标识符"为所定义的宏名；"字符串"可以是常数、表达式、字符串等。

（2）除了经常用到的如"#define MAXNUM 100"之外，还有其它多种灵活的用法，如"#define M （y*y+3*y）",注意，的表达式中（）是必须的，否则在进行如"2*M+2"的运算时就会出现错误。

（3）末尾不需要分号（如果加分号，会连同分号一起代换）。

（4）define只是做简单的文本替换。

（5）作用域为宏定义开始，到源程序结束，终止定义域可用"#undef M".

（6）宏名如果以字符串的形式被调用，则不做替换，如printf（"I M O"）。

（7）可以嵌套进行定义，如：

```cpp
    #define PI 3.14
    #define S PI*R*R
```

（8）习惯上把宏名写为大写的，以区别普通的变量。


##### 2、define和typedef的区别

define宏定义是在预处理完成的，typedef实在编译时处理的，typedef不是简单的代换，而是对类型说明符的重命名。

例如：

```cpp
#define P1 int*
typedef int* P2;
P1 a, b;    //相当于int* a, b,此时a是int指针，b是int整数。
P2 a, b;    //表示a和b都是int指针。
```

##### 3、define（带参数宏定义）用法

一般形式为：#define 宏名（形参） 字符串

最长见的 #define MAX（a,b） （a>b）？a:b

（1）宏名和形参之间不能有空格。如果上式写为 #define MAX （a,b） （a>b）？a:b,则MAX就表示整个后面的部分了。

（2）带参宏定义的形参是不分配内存的。

（3） 在宏定义中的形参是标识符，而宏调用中的实参可以是表达式。

```cpp
#define SQ(y) (y)*(y)
main(){
    int a,sq;
    printf("input a number:    ")；
    scanf("%d",&a)；
    sq=SQ(a+1)；
    printf("sq=%d\n",sq)；
}
```

上例中第一行为宏定义，形参为y。程序第七行宏调用中实参为a+1,是一个表达式，在宏展开时，用a+1代换y,再用（y）*（y）代换SQ,得到如下语句 :

sq=（a+1）*（a+1）；

这与函数的调用是不同的，函数调用时要把实参表达式的值求出来再赋予形参。而宏代换中对实参表达式不作计算直接地照原样代换。

（4） 在宏定义中，字符串内的形参通常要用括号括起来以避免出错。在上例中的宏定义中（y）*（y）表达式的y都用括号括起来，因此结果是正确的。如果去掉括号，把程序改为以下形式：

```cpp
#define SQ(y) y*y
mai(){
    int a,sq;
    printf("input a number:    ")；
    scanf("%d",&a)；
    sq=SQ(a+1)；
    printf("sq=%d\n",sq)；
}
```

运行结果为：

input a number:3

sq=7



##### 4、define宏和函数的区别


（1）宏定义可以帮助我们防止出错，提高代码的可移植性和可读性等。
    
看一个例子，比较两个数或者表达式大小，首先我们把它写成宏定义：

```cpp
#define MAX(a, b) ( (a) > (b)?(a) : (b) )
```


其次，把它用函数来实现：

```cpp
int max(int a, int b)
{
    return (a > b a : b)
}    
```                  

很显然，我们不会选择用函数来完成这个任务，原因有两个：

首先，函数调用会带来额外的开销，它需要开辟一片栈空间，记录返回地址，将形参压栈，从函数返回还要释放堆栈。这种开销不仅会降低代码效率，而且代码量也会大大增加，而使用宏定义则在代码规模和速度方面都比函数更胜一筹；

其次，函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用，我们如果要比较两个浮点型的大小，就不得不再写一个专门针对浮点型的比较函数。反之，上面的那个宏定义可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用">"操作符比较值大小的类型，也就是说，宏是与类型无关的。

和使用函数相比，使用宏的不利之处在于每次使用宏时，一份宏定义代码的拷贝都会插入到程序中。除非宏非常短，否则使用宏会大幅度增加程序的长度。还有一些任务根本无法用函数实现，但是用宏定义却很好实现。比如参数类型没法作为参数传递给函数，但是可以把参数类型传递给带参的宏。

看下面的例子：

```cpp
#define MALLOC(n, type) ((type *) malloc((n)* sizeof(type)))
```

利用这个宏，我们就可以为任何类型分配一段我们指定的空间大小，并返回指向这段空间的指针。我们可以观察一下这个宏确切的工作过程：

```cpp
int *ptr;
ptr = MALLOC(5, int)；
```

将这宏展开以后的结果：

```cpp
ptr =(int *)malloc((5)* sizeof(int)；
```

这个例子是宏定义的经典应用之一，完成了函数不能完成的功能，但是宏定义也不能滥用，通常，如果相同的代码需要出现在程序的几个地方，更好的方法是把它实现为一个函数。


（2）下面总结和宏和函数的不同之处，以供大家写代码时使用，这段总结摘自《C和指针》一书。

1.代码长度

"#define"宏：每次使用时，宏代码都被插入到程序中。除了非常小的宏之外，程序的长度将大幅度增长

函数：函数代码只出现于一个地方：每次使用这个函数时，都调用那个地方的同一份代码

2.执行速度

"#define宏"：更快

函数： 存在函数调用、返回的额外开销

3.操作符优先级

"#define宏"：宏参数的求值是在所有周围表达式的上下文环境里，除非它们加上括号，否则邻近操作符的优先级可能产生不可预料的结果。

函数：函数参数只在函数调用时求值一次，它的结果值传递给函数。表达式的求值结果更容易预测。

4.参数求值

"#define宏"：参数用于宏定义时，每次都将重新求值，由于多次求值，具有副作用的参数可能会产生不可预测的结果。

函数：参数在函数调用前只求值一次，在函数中多次使用参数并不会导致多次求值过程，参数的副作用并不会造成任何特殊问题。

5.参数类型

"#define宏"：宏与类型无关，只要参数的操作是合法的，它可以用于任何参数类型。

函数： 函数的参数是与类型有关系的，如果参数的类型不同，就需要使用不同的函数，即使它们执行的任务是相同的。