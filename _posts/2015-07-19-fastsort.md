---
layout: post
title: 快速排序算法
categories: 数据结构
description: 排序快速算法
keywords: C, 排序
---

**希尔排序相当于直接插入排序的升级，它们同属于插入排序类；堆排序相当于简单选择排序的升级，它们同属于选族排序类；而快速排序其实就是我们前面认为最慢的冒泡排序的升级，它们同属于交换排序类；**即它是通过不断比较和移动交换来实现排序的，只不过它的实现，增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从后面直接移动到前面，从而减少了总的比较次数和移动次数。 

#### 快速排序算法的思想

**快速排序（Quick Sort）的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的**。

比如我们要排序{50,10,90,30,70,40,80,60,20}。**首先就是选取当中一个关键字，比如选择第一个关键字50，然后想尽办法将它放置到一个位置，使得它左边的值都比它小，右边的值都比它大，我们将这样的关键字称为枢轴（pivot）**。这样我们得到两位位于50左和右小数组{20,10,40,30}和{70,80,60,90}。然后继续递归分割进行同样的操作，知道顺序全部正确为止。

然后从数组的两端low、high交替开始扫描，比如从右边到左边开始比较,枢轴为50,小于枢轴则发送交换：

![](/images/posts/Datastructure/173.png)

![](/images/posts/Datastructure/174.png)

然后从左边到右边，大于50则发生交换：

![](/images/posts/Datastructure/175.png)

继续从右边到左边，小于50则发生交换：

![](/images/posts/Datastructure/176.png)

如此循环：

![](/images/posts/Datastructure/177.png)

![](/images/posts/Datastructure/178.png)




