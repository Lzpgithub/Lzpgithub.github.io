---
layout: post
title: 进程的同步
categories: 操作系统
description: 进程的同步
keywords: C, 进程，同步
---

#### 进程同步引入例子

同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。

例如，输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒。反之，当缓冲区满时，进程A被阻塞，仅当进程B取走缓冲数据时，才唤醒进程A。

计算进程和打印进程共同使用同一缓冲区Buf，计算进程反复地把每次计算结果放入Buf中，而打印进程则把计算进程每次放入Buf中的数据通过打印机打印输出。

**当缓冲区有数据的时候，计算进程不能把数据放入缓冲区，必须等待打印进程把数据取走，因此计算进程受到打印进程的制约。反过来，如果缓冲区没有数据，打印进程无法取得数据，必须等待计算进程把数据放进缓冲区，因此打印进程受到计算进程的制约。总结来说，计算进程和打印进程都是相互制约，又相互合作，二者必须按照一定的顺序执行（先执行计算进程，再执行打印进程），同时相互等待，我们把这样的关系称之为进程同步**。

![](/images/posts/OS/24.png)

如果不采取任何制约措施，这两个进程的执行起始时间和执行速度都是彼此独立的，其相应的控制段可以描述为：

![](/images/posts/OS/22.png)

假定进程Pc和Pp对公用缓冲区Buf已经采用了互斥措施。

显然，如果按照上面的描述并发执行进程Pc和Pp，则会造成造成CPU时间的极大浪费，因为其中包含有二处反复测试语句，这是操作系统所不允许的。CPU时间的浪费主要是由于进程Pc和Pp的执行相互制约所起的。Pc进程的输出结果是Pp执行的条件，反之，Pp的执行结果也是Pc的执行条件。这种现象在操作系统和用户进程中大量存在。与进程互斥不同的是，进程互斥时进程的执行顺序是可以随意的。


#### 进程同步概念

一组在异步环境下的并发进程，各自的执行结果互为对方的执行条件，从而限制个进程的执行速度的过程称为并发进程间的直接制约。

由以上的例子可知，如果没有相应的解决办法，进程的直接制约将会造成大量的CPU时间浪费。一种最为简单和直观的方法是直接制约的进程互相给对方进程发送执行条件已经具备的信号。这样，被制约的进程即可省去对执行条件的测试，只要收到制约进程发过来的信号便开始执行，而在未收到制约进程发过来的信号时便进入等待状态。

把异步环境下的一组并发进程，因直接制约而互相发送消息而进行互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程间的同步。具有同步关系的一组并发进程称为合作进程，合作进程间相互发送的信号称为消息或事件。

表示进程等待合作进程发过来的消息：

wait(消息名)

表示向合作进程发送消息：

signal(消息名)

利用过程wait和signal，可以简单地描述上面例子中的计算进程Pc和打印进程Pb的同步关系如下：

1.设消息名Bufempty表示Buf为空，消息名Buffull表示Buf中装满了数据；

2.初始化Bufempty=true，Buffull=false；

3.描述：

![](/images/posts/OS/23.png)


过程wait的功能是等待到消息名为true的进程继续执行，而signal的功能是向合作进程发送所需要的消息名，并将其值置为true。


#### 经典同步问题--生产者和消费者

##### 问题描述

一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。

##### 问题分析

1) 关系分析。生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，他们也是同步关系。

2) 整理思路。这里比较简单，只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步PV操作的位置。

3) 信号量设置。信号量mutex作为互斥信号量，它用于控制互斥访问缓冲池，互斥信号量初值为1；信号量full用于记录当前缓冲池中“满”缓冲区数，初值为0。信号量empty 用于记录当前缓冲池中“空”缓冲区数，初值为n。

生产者-消费者进程的描述如下：

```cpp
semaphore mutex=1;            //临界区互斥信号量
semaphore empty=n;            //空闲缓冲区
semaphore full=0;             //缓冲区初始化为空
producer () {                 //生产者进程
    while(1){
        produce an item in nextp;  //生产数据
        P(empty);             //获取空缓冲区单元
        P(mutex);             //进入临界区.
        add nextp to buffer;  //将数据放入缓冲区
        V(mutex);             //离开临界区,释放互斥信号量
        V(full);              //满缓冲区数加1
    }
}
consumer () {                 //消费者进程
    while(1){
        P(full);              //获取满缓冲区单元
        P(mutex);             //进入临界区
        remove an item from buffer;  //从缓冲区中取出数据
        V (mutex);            //离开临界区，释放互斥信号量
        V (empty);            //空缓冲区数加1
        consume the item;     //消费数据
    }
}
```

#### 经典同步问题--吃水果

##### 问题描述

桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等吃盘子中的橘子，女儿专等吃盘子中的苹果。只有盘子为空时，爸爸或妈妈就可向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出。

##### 问题分析

1) 关系分析。这里的关系稍复杂一些，首先由每次只能向其中放入一只水果可知爸爸和妈妈是互斥关系。爸爸和女儿、妈妈和儿子是同步关系，而且这两对进程必须连起来，儿子和女儿之间没有互斥和同步关系，因为他们是选择条件执行，不可能并发，如图2-8所示。

2) 整理思路。这里有4个进程，实际上可以抽象为两个生产者和两个消费者被连接到大小为1的缓冲区上。

![](/images/posts/OS/62.png)

3) 信号量设置。首先设置信号量plate为互斥信号量，表示是否允许向盘子放入水果，初值为1，表示允许放入，且只允许放入一个。信号量 apple表示盘子中是否有苹果，初值为0，表示盘子为空，不许取，若apple=l可以取。信号量orange表示盘子中是否有橘子，初值为0，表示盘子为空，不许取，若orange=l可以取。

解决该问题的代码如下：

```cpp
semaphore plate=l, apple=0, orange=0;

dad() {                                   //父亲进程
    while (1){
        prepare an apple;
        P(plate) ;                        //互斥向盘中取、放水果
        put the apple on the plate;       //向盘中放苹果
        V(apple);                         //允许取苹果
    }
}

mom() {                                   //母亲进程
    while(1){
        prepare an orange;
        P(plate);                         //互斥向盘中取、放水果
        put the orange on the plate;      //向盘中放橘子
        V(orange);                        //允许取橘子
    }
}

son(){                                    //儿子进程
    while(1){
        P(orange) ;                       //互斥向盘中取橘子
        take an orange from the plate;
        V(plate);                         //允许向盘中取、放水果
        eat the orange;
    }
}

daughter (){                              //女儿进程
    while(1) {
        P(apple);                         //互斥向盘中取苹果
        take an apple from the plate;
        V(plate);                         //运行向盘中取、放水果
        eat the apple;
    }
}
```

#### 经典同步问题--读进程和写进程

##### 问题描述

有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：
（1）允许多个读者可以同时对文件执行读操作；

（2）只允许一个写者往文件中写信息；

（3）任一写者在完成写操作之前不允许其他读者或写者工作；

（4）写者执行写操作前，应让已有的读者和写者全部退出。

##### 问题分析

1) 关系分析。由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。

2) 整理思路。两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。读者的问题比较复杂，它必须实现与写者互斥的同时还要实现与其他读者的同步，因此，仅仅简单的一对P操作、V操作是无法解决的。那么，在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件，当没有读者的时候写者才可以写文件。同时这里不同读者对计数器的访问也应该是互斥的。

3) 信号量设置。首先设置信号量count为计数器，用来记录当前读者数量，初值为0; 设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw用于保证读者和写者的互斥访问。

代码如下：

```cpp
int count=0;              //用于记录当前的读者数量
semaphore mutex=1;        //用于保护更新count变量时的互斥
semaphore rw=1;           //用于保证读者和写者互斥地访问文件

writer(){                 //写者进程
    while(1){
        P(rw);            //互斥访问共享文件
        Writing;          //写入
        V(rw) ;           //释放共享文件
    }
}

reader(){                 // 读者进程
    while(1){
        P (mutex) ;       //互斥访问count变量
        if (count==0)     //当第一个读进程读共享文件时
            P(rw);        //阻止写进程写
        count++;          //读者计数器加1
        V(mutex) ;        //释放互斥变量count
        reading;          //读取
        P(mutex) ;        //互斥访问count变量
        count--;          //读者计数器减1
        if (count==0)     //当最后一个读进程读完共享文件
            V(rw) ;       //允许写进程写
        V (mutex) ;       //释放互斥变量 count
    }
}
```

在上面的算法中，读进程是优先的，也就是说，当存在读进程时，写操作将被延迟，并且只要有一个读进程活跃，随后而来的读进程都将被允许访问文件。这样的方式下，会导致写进程可能长时间等待，且存在写进程“饿死”的情况。

如果希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等待到已在共享文件的读进程执行完毕则立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。为此，增加一个信号量并且在上面的程序中 writer()和reader()函数中各增加一对PV操作，就可以得到写进程优先的解决程序。

```cpp
int count = 0;               //用于记录当前的读者数量
semaphore mutex = 1;         //用于保护更新count变量时的互斥
semaphore rw=1;              //用于保证读者和写者互斥地访问文件
semaphore w=1;               //用于实现“写优先”

writer(){
    while(1){
        P(w);                //在无写进程请求时进入
        P(rw);               //互斥访问共享文件
        writing;             //写入
        V(rw);               //释放共享文件
        V(w) ;               //恢复对共享支件的访问
    }
}

reader(){                    //读者进程
    while(1){
        P (w) ;              //在无写进程请求时进入
        P (mutex);           //互斥访问count变量
        if (count==0)        //当第一个读进程读共享文件时
            P(rw);           //阻止写进程写
        count++;             //读者计数器加1
        V (mutex) ;          //释放互斥变量count
        V(w);                //恢复对共享文件的访问
        reading;             //读取
        P (mutex) ;          //互斥访问count变量
        count--;             //读者计数器减1
        if(count==0)         //当最后一个读进程读完共享文件
            V(rw);           //允许写进程写
        V (mutex);           //释放互斥变量count
    }
}
```

#### 经典同步问题--哲学家进餐问题

##### 问题描述

一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭，如图2-10所示。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、 右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。

##### 问题分析

1) 关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。

2) 整理思路。显然这里有五个进程。本题的关键是如何让一个哲学家拿到左右两个筷子而不造成死锁或者饥饿现象。那么解决方法有两个，一个是让他们同时拿两个筷子；二是对每个哲学家的动作制定规则，避免饥饿或者死锁现象的发生。

![](/images/posts/OS/63.png)

3) 信号量设置。定义互斥信号量数组Ch0PstiCk[5] = {l, 1, 1, 1, 1}用于对5个筷子的互斥访问。

对哲学家按顺序从0～4编号，哲学家i左边的筷子的编号为i，哲学家右边的筷子的编号为(i+l)%5。

```cpp
semaphore chopstick[5] = {1,1,1,1,1};   //定义信号量数组chopstick[5],并初始化

Pi(){                                   //i号哲学家的进程
    do{
        P (chopstick[i] ) ;             //取左边筷子
        P (chopstick[(i+1) %5] )；      //取右边篌子
        eat;                            //进餐
        V(chopstick[i]) ;               //放回左边筷子
        V(chopstick[(i+l)%5]);          //放回右边筷子
        think;                          //思考
    } while (1);
}
```

该算法存在以下问题：当五个哲学家都想要进餐，分别拿起他们左边筷子的时候（都恰好执行完wait(chopstick[i]);)筷子已经被拿光了，等到他们再想拿右边的筷子的时候（执行 wait(chopstick[(i+l)%5]);)就全被阻塞了，这就出现了死锁。

为了防止死锁的发生，可以对哲学家进程施加一些限制条件，比如至多允许四个哲学家同时进餐;仅当一个哲学家左右两边的筷子都可用时才允许他抓起筷子;对哲学家顺序编号，要求奇数号哲学家先抓左边的筷子，然后再转他右边的筷子，而偶数号哲学家刚好相反。正解制定规则如下：假设釆用第二种方法，当一个哲学家左右两边的筷子都可用时，才允许他抓起筷子。

```cpp
semaphore chopstick[5] = {1,1,1,1,1};       //初始化信号量
semaphore mutex=l;                          //设置取筷子的信号量
Pi(){                                       //i号哲学家的进程
    do{
        P (mutex) ;                         //在取筷子前获得互斥量
        P (chopstick [i]) ;                 //取左边筷子
        P (chopstick[ (i+1) %5]) ;          //取右边筷子
        V (mutex) ;                         //释放取筷子的信号量
        eat;                                //进餐
        V(chopstick[i] ) ;                  //放回左边筷子
        V(chopstick[ (i+l)%5]) ;            //放回右边筷子
        think;                              //思考
    }while(1);
}
```

#### 经典同步问题--抽烟者

##### 向题描述

假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟 并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟 者中，第一个拥有烟草、第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料， 供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供 应者一个信号告诉完成了，供应者就会放另外两种材料在桌上，这种过程一直重复（让三个 抽烟者轮流地抽烟)。

##### 问题分析

1) 关系分析。供应者与三个抽烟者分别是同步关系。由于供应者无法同时满足两个或 以上的抽烟者，三个抽烟者对抽烟这个动作互斥（或由三个抽烟者轮流抽烟得知

2) 整理思路。显然这里有四个进程。供应者作为生产者向三个抽烟者提供材料。

3) 信号量设置。信号量offer1、offer2、offer3分别表示烟草和纸组合的资源、烟草和 胶水组合的资源、纸和胶水组合的资源。信号量finish用于互斥进行抽烟动作。

代码如下：

```cpp
int random;             //存储随机数
semaphore offer1=0;     //定义信号量对应烟草和纸组合的资源
semaphore offer2=0;     //定义信号量对应烟草和胶水组合的资源
semaphore offer3=0;     //定义信号量对应纸和胶水组合的资源
semaphore finish=0;     //定义信号量表示抽烟是否完成
                        //供应者
while(1){
    random = 任意一个整数随机数;
    random=random% 3;
    if(random==0)
        V(offerl) ;     //提供烟草和纸
    else if(random==l) 
        V(offer2);      //提供烟草和胶水
    else
        V(offer3)       //提供纸和胶水
                        //任意两种材料放在桌子上;
    P(finish);
}

//拥有烟草者
while(1){
    P (offer3);
    // 拿纸和胶水，卷成烟，抽掉;
    V(finish);
}

//拥有纸者
while(1){
    P(offer2);
    // 烟草和胶水,卷成烟，抽掉；
    V(finish);
}

//拥有胶水者
while(1){
    P(offer1);
    // 拿烟草和纸，卷成烟，抽掉;
    v(finish);
}
```


