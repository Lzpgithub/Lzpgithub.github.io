---
layout: post
title: 类成员函数
categories: C和C++基础
description: 类成员函数
keywords: 类，成员函数
---

#### 类成员函数的性质

类的成员函数(简称类函数)是函数的一种，它的用法和作用和普通函数基本上是一样的，它也有返回值和函数类型，它与一般函数的区别只是：它是属于一个类的成员，出现在类体中。它可以被指定为private(私有的)、public(公用的)或protected(受保护的)。私有的成员函数只能被本类中的其他成员函数所调用，而不能被类外调用。

成员函数可以访问本类中任何成员(包括私有的和公用的)，可以引用在本作用域中有效的数据。

一般的做法是将需要被外界调用的成员函数指定为public，它们是类的对外接口。但应注意，并非要求把所有成员函数都指定为public。有的函数并不是准备为外界调用的，而是为本类中的成员函数所调用的，就应该将它们指定为private。如果一个类中不包含成员函数，就等同于C语言中的结构体了，体现不出类在面向对象程序设计中的作用。

#### 在类外定义成员函数

成员函数是在类体中定义的。也可以在类体中只写成员函数的声明，而在类的外面进行函数定义：

```cpp
class Studenclass Student
{ public:
	void display( );       //公用成员函数原型声明
  private: 
	int num;
	string name;
	char sex;              //以上3行是私有数据成员
};
void Studen::display( )    //在类外定义display类函数
{
	cout<<"num:"<<num<<endl;     //函数体
	cout<<"name:"<<name<<endl;
	cout<<"sex:"<<sex<<endl;
}
Student stud1,stud2;       //定义两个类对象
```

在类体中直接定义函数时，不需要在函数名前面加上类名，因为函数属于哪一个类是不言而喻的。但成员函数在类外定义时，必须在函数名前面加上类名，予以限定(qualifed)，“::”是作用域限定符(field qualifier)或称作用域运算符，用它声明函数是属于哪个类的。

如果在作用域运算符“::”的前面没有类名，或者函数名前面既无类名又无作用域运算符::”，如::display( )或display( )则表示display函数不属于任何类，这个函数不是成员函数，而是全局函数，即非成员函数的一般普通函数。

类函数必须先在类体中作原型声明，然后在类外定义，也就是说类体的位置应在函数定义之前，否则编译时会出错。虽然函数在类的外部定义，但在调用成员函数时会根据在类中声明的函数原型找到函数的定义（函数代码），从而执行该函数。

#### inline成员函数

类的成员函数也可以指定为内置函数。在类体中定义的成员函数的规模一般都很小，而系统调用函数的过程所花费的时间开销相对是比较大的。调用一个函数的时间开销远远大于小规模函数体中全部语句的执行时间。为了减少时间开销，如果在类体中定义的成员函数中不包括循环等控制结构，C++系统会自动将它们作为内置(inline)函数来处理。也就是说，在程序调用这些成员函数时，并不是真正地执行函数的调用过程(如保留返回地址等处理)，而是把函数代码嵌入程序的调用点。这样可以大大减少调用成员函数的时间开销。

C++要求对一般的内置函数要用关键字inline声明，但对类内定义的成员函数，可以省略inline，因为这些成员函数已被隐含地指定为内置函数。

```cpp
class Student
{public:
	void display( )
	{
		cout<<"num:"<<num<<endl;
		cout<<"name:"<<name<<endl;
		cout<<"sex:"<<sex<<endl;
	}
 private:
	int num;
	string name;
	char sex;
};
```

void display()可以写成inline void display()，将display函数显式地声明为内置函数。以上两种写法是等效的。对在类体内定义的函数，一般都省写inline。

如果成员函数不在类体内定义，而在类体外定义，系统并不把它默认为内置(inline)函数，调用这些成员函数的过程和调用一般函数的过程是相同的。如果想将这些成员函数指定为内置函数，应当用inline作显式声明。如：

```cpp
class Student
{ public:
	inline void display( );     //声明此成员函数为内置函数
  private:
	int num;
	string name;
	char sex;
};

inline void Student::display( ) //在类外定义display函数为内置函数
{
	cout<<"num:"<<num<<endl;
	cout<<"name:"<<name<<endl;
	cout<<"sex:"<<sex<<endl;
}
```

只有在类外定义的成员函数规模很小而调用频率较高时，才将此成员函数指定为内置函数。

#### 成员函数的存储方式

用类去定义对象时，系统会为每一个对象分配存储空间。如果一个类包括了数据和函数，要分别为数据和函数的代码分配存储空间。按理说，如果用同一个类定义了10个对象，那么就需要分别为10个对象的数据和函数代码分配存储单元。

![](/images/posts/C++/11.png)

能否只用一段空间来存放这个共同的函数代码段，在调用各对象的函数时，都去调用这个公用的函数代码。

![](/images/posts/C++/12.png)

这样做会大大节约存储空间。C++编译系统正是这样做的，因此每个对象所占用的存储空间只是该对象的数据部分所占用的存储空间，而不包括函数代码所占用的存储空间。

比如声明一个类：

```cpp
class Time
{public:
	int hour;
	int minute;
	int sec;
	void set( )
	{
		cin>>a>>b>>c;
	}
};

cout<<sizeof(Time)<<endl;  //输出的值是12
```

证明了一个对象所占的空间大小只取决于该对象中数据成员所占的空间，而与成员函数无关。函数代码是存储在对象空间之外的。如果对同一个类定义了10个对象，这些对象的成员函数对应的是同一个函数代码段，而不是10个不同的函数代码段。

虽然调用不同对象的成员函数时都是执行同一段函数代码，但是执行结果一般是不相同的。不同的对象使用的是同一个函数代码段，它怎么能够分别对不同对象中的数据进行操作呢？原来C++为此专门设立了一个名this的指针，用来指向不同的对象。

