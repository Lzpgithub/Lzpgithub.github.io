---
layout: post
title: const(常量)
categories: C和C++基础
description: 编程基础。
keywords: C++，基础
---

**const是C语言的一个关键字，它所限定变量不允许改变**。使用const可以在一定程度上增强程序的健壮性，减少程序出错。虽然const有诸多优势，但是const的使用却并不简单。

##### 7.找错--const的使用

```cpp
#include <stdio.h>

int main(){
	const int x=1;
	int b=10;
	int c=20;
	
	const int* a1=&b;
	int* const a2=&b;
	const int* const a3=&b;
	
	x=2;    //错
	
	a1=&c;  //对
	*a1=1;  //错
	
	a2=&c;  //错
	*a2=1;  //对

	a3=&c;  //错
	*a3=1;  //错
	
	return 0;
}
```

##### 8.请说明const与#define的各自特点以及区别

解析：

\#define只是用来做文本替换，例如：

```cpp
#define PI 3.1415926
float angel;
angel=30*PI/180;
```

当程序进行编译的时候，编译器会首先将**\#define PI 3.1415926**以后所有代码中的“PI”全部换成3.1415926，然后在进行编译。因此#define常量的声明周期止于编译期，它存在于程序的代码段，在实际程序中它只是一个常数，一个命令中的参数，并没有实际的存在。

const常量存在于程序的数据段，并在堆栈中分配了空间。const常量是一个Run-Time的概念，它在程序中确确实实地存在着，并可以被调用、传递。const常量有数据类型，而宏常量没有数据类型。编译器可以对const常量进行类型安全检查。

```cpp
静态检查：书中对静态检查的阐述：“编译器必须检查源程序是否符合源语言规定的语法和语义要求。”由此看来，静态检查其实就是语义分析了。

类型错误：将int赋给一个指针就是类型错误。

类型检查：检查类型错误，属于静态检查的一部分，编译器实现可能有两种情况：第一种是将中间代码生成、类型检查放到语法分析一起做，完成语法分析的同时进行语义分析。对于某些复杂的结构，则将类型检查作为语法分析和中间代码生成之间单独的一遍。

强类型语言：某语言的编译器保证所接受的程序不会在运行时发生“类型错误”，则此语言是强类型语言。

类型安全语言：将int赋给一个指针，C/C++会编译器会抱错，于是C/C++称为类型安全语言.。似乎“类新安全”和“强类型”本质上一样。
```

##### 9.C++中const有什么作用？至少说三种。

1.const用于定义常量：const定义的常量编译器可以对其进行数据静态类型安全检查。

2.const修饰函数形式参数：当输入参数为用户自定义类型和抽象数据类型时，将“值传递”该为“const&传递”可以提高效率，例如以下代码：

```cpp
void fun(A a);
void fun(A const &a);
```

第一个函数效率低。函数体内产生A类型的临时对象用于“值传递”参数a，临时对象的构造、复制、析构过程都将消耗时间。而第二个函数提高了效率。用“引用传递”不需要产生临时对象，省了临时对象的构造、复制、析构过程消耗的时间，但只用引用有可能改变a，所以要加上const。

3.const修饰函数的返回值：如果给“指针传递”的函数返回值加const，则返回值不能被直接修改，且该返回值只能赋值给const修饰的同类型指针。例如：

```cpp
const char *GetChar(void){};
char *ch=GetChar();            //error
const char *ch=GerChar();      //correct
```

4.const修饰类的成员函数（函数定义体）：任何不需要修改数据成员的函数都应该使用const修饰，这样即使不小心修改了数据成员或调用了非const成员函数，编译器也会报错。const修饰类的成员函数形式为：

```cpp
int GetCount(void) const;
```