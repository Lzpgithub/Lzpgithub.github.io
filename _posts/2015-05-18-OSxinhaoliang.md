---
layout: post
title: 信号量和P,V原语
categories: 操作系统
description: 信号量和P,V原语
keywords:  信号量, P,V原语
---

尽管用加锁的方法可以实现进程之间的互斥，但是这种方法仍然存在一些影响系统可靠性和执行效率的问题。

#### 加锁法产生的问题

循环测试锁定位将损耗较多的CPU计算时间，如果一组并发进程的进程数较多，且由于每个进程在申请进入临界区都得对锁定位进行测试，这种开销会很大的。

另外使用加锁法实现进程间的互斥时，还将导致在某些情况下出现不公平现象，试考虑以下进程Pa和Pb反复使用临界区的情况：

![](/images/posts/OS/17.png)

设进程Pa已通过lock(key[s])过程而进入临界区，显然，在进程Pa执行unlock(key[s])过程之前，key[s]=0且进程Pb没有进入临界区的机会。然而，当进程Pa执行完unlock(key[s])过程之后，由于紧接着是一个转向语句，进程Pa又立即去执行lock(key[s])过程，此时由于unlock(key[s])的过程已经将key[s]的值置为1，也即是开锁状态，从而使进程Pa又可进入临界区。只有在进程Pa执行完unlock(key[s])过程之后、执行Goto A语句之前的一瞬间发生进程调度，使进程Pa把处理机转让给进程Pb，进程Pb才有可能得到执行。但是这种可能性非常小，因此进程Pb将处于永久饥饿状态。

产生上述问题的原因是：在用加锁法解决进程互斥的问题时，一个进程能否进入临界区是依靠进程自己调用lock过程去测试相应的锁定位。也就是说每个进程能否进入临界区是依靠自己的测试判断。这样，没有获得执行机会的进程当然无法判断，从而出现不公平的现象，而获得了测试机会的进程有因为需要测试而损失一定的CPU时间。

比如某个学生想使用一个人人都可借、且不规定使用时间的教室。他必须首先申请获得使用该教室的权利，到教室看看该教室是不是被锁上，如果该教室被锁上，他只好下次再来观察，看该教室的门是否已经被打开。这种反复持续到他进门后为止。

为了解决这个问题，一种最为直观的办法是设置一个教室管理员，如果有学生申请使用教室而未能如愿时，教室管理员会记下他的名字，并等到教室门一打开则通知该学生进入，这样既减少了学生多次去教室检查门是否被打开的时间，又减少了因为学生自发地检查造成的不公平现象(有的学生可能来十几次也进不了教室的门，但有的学生可能一次就进去了，或不断地出出进进)。

在操作系统中，这个管理员就是信号量。信号量管理相应的临界资源，它代表了可用资源的实体。

#### 信号量

信号量的概念又荷兰科学家E.W.Dijkstra提出来。信号是铁路交通管理中的一种常用设备，交通管理人员利用信号的颜色变化来实现交通管理。在操作系统中，信号量sem是一整数，在sem大于等于零时代表可供并发进程使用的资源实体数，但sem小于零时则表示正在等待使用临界区的进程数。显然，用于互斥的信号量的初值应大于零。

#### P,V原语

信号量的数值仅能由P，V原语操作改变(P和V分别是荷兰语Passeren和Verhoog的头一个字母，相当于英文的pass和increment的意思)。经常

假设，sem是与临界区内所使用的公有资源有关的信号量。一次P原语操作使得信号量sem减1，而一次V原语操作将使得信号量sem加1.

当某个进程正在临界区内执行时，如果其他进程执行了P原语操作，则该进程并不像用lock时那样因为进不了临界区而返回到lock的起点，等以后重新执行测试，而是在等待队列中等待有其他进程做V原语操作释放资源后，才进入临界区，这是P原语的执行才算真正结束。当有好几个进程执行P原语未通过而进入等待队列后，如有某进程做了V原语操作，则等待进程中的一个可以进入临界区，但其他进程必须等待。

P原语操作的主要动作是：

1.sem减1；

2.若sem减1后仍大于或等于零，则P原语返回，该进程继续执行；

3.若sem减1后小于零，则该进程被阻塞后，进入等待队列中，然后进行转进程调度。

![](/images/posts/OS/18.png)

V原语操作的主要动作是：

1.sem加1；

2.若相加结果大于零，V原语停止执行，该进程返回调用处，继续执行；

3.若相加结果小于或等于零，则从该信号的等待队列中唤醒一等待进程，然后在返回原进程继续执行或转进程调度。

![](/images/posts/OS/19.png)

P,V过程要以原语实现的原因：如果多个进程同时调用P操作或V操作的话，则有可能在P操作时刚把sem-1而未把对应的进程送入等待队列时，V操作开始执行，从而，V操作将无法发现等待进程而返回。因此P,V操作必须以原语实现，且在P,V原语执行期间不允许中断发生。

关于P,V原语的实现，这里介绍一种使用加锁法的软件实现方法：

![](/images/posts/OS/20.png)

![](/images/posts/OS/21.png)


#### P,V原语实现进程同步

设置信号量sem是用于互斥的信号量，其初始值为1表示并没有并发进程使用该临界区。只要把临界区置于P(sem)和V(sem)之间，即可实现进程间的互斥。当一个进程想要进入临界区时，它必须先执行P原语操作以将信号量sem减1。在一个进程完成对临界区的操作后，它必须执行V原语操作以释放它所占的的临界区。由于信号量的初始值为1，所以，任一进程在执行P原语操作之后将sem的值变为0，表示该进程可以进入临界区。在该进程未执行V原语操作之前，如有一个进程想进入临界区的话，它也应先执行P原语操作，使sem的值变为-1，因此，第二个进程被阻塞。直到第一个进程执行V原语操作以后，sem的值变为0，从而唤醒第二个进程进入就绪队列，经过调度进入临界区。在第二个进程执行完V原语操作以后，如果没有其他进程申请进入临界区，则sem值又恢复到初始值。

用信号量实现两个并发进程Pa和Pb互斥的描述如下：

(1).设sem为互斥信号量，其取值范围为(1,0,-1);

其中sem=1表示进程Pa和Pb都未进入类名为s的临界区，sem=0表示进程Pa或Pb已经进入临界区s，sem=-1表示进程Pa和Pb中，一个进程进入临界区，而另一个进程进入等待队列。

(2).描述：

![](/images/posts/OS/22.png)
